---
title: "WHOQOLBREF LEARNING"
output: html_document
date: "2025-08-13"
editor_options: 
  chunk_output_type: console
---
1) FIRST THINGS FIRST :P
```{r}
setwd("/Volumes/Hera/Angela")
load('/Volumes/Hera/Projects/7TBrainMech/scripts/behave/svys.RData') #this is svys in data env.
merg7T_raw <- read.csv("/Volumes/Hera/Projects/hippocampal_myelin/sample_info/merge_7t_04172025.csv")
library(dplyr)
```

1.5) SYS GLOB
```{r}
#Y2HF <- svys[["7T Y2 Hybrid Female Survey Battery"]] ## THIS IS JUST AN EXAMPLE ##

# this will be named svys on under the environment data #
#note: finding where all those files are, the * is a placeholder(glob placeholder)
all_csv <- Sys.glob('/Volumes/L/bea_res/Data/Temporary Raw Data/7T/*/*_selfreport.csv') 


```

IN DIFFERENT BATTERIES THE WHOQOL QUESTIONS WILL BE IN A DIFFERENT POSITION SVY BATTERIES

2) LOOK FOR WHOQOL ITEMS!!!
note: this is how we can look for specific items that we want to work within the data! 
```{r}
names(data) |> grep(pattern = 'quality')
# answer is 467
names(data) |> grep(pattern = 'quality', value = TRUE)
# answer is "Q173...How.would.you.rate.your.quality.of.life."
```

3) CREATING A FUNCTION TO READ WHOQOL STUFF <3
note: curly brackets defines the functions code; this function reads in CSV files, will extract specific columns related to WHOQOL items plus some demo info, and renames the columns, and returns only the last row of data to use later (f iS placeholder for filename) 
```{r}
readwhoqol <- function(f) {
   d <- read.csv(f, skip = 1)
   if(ncol(d) < 20) return(NULL) #a quick qc to ignore files with missing/incomplete data
  dob <- names(d) |> grep(pattern = "birthday")
  #d[dob] <- as.character(d[dob]) 
  sex <- names(d) |> grep(pattern = "gender")
  #d[sex] <- as.character(d[sex])
  i <- names(d) |> grep(pattern = 'quality')
  names(d)[i: (i+25)] <- paste('whoqol', 1:26, sep = '') #renaming columns to be whoqol1 to whoqol26
  eyes <- c(i: (i+25), sex, dob) #columns of interest to extract from
  whoqol <- d [, eyes] |> mutate(across(everything(), as.character))
  whoqol$file <- f
  return(whoqol[nrow(whoqol),])
}

allwhoqol <- lapply(all_csv, readwhoqol)
whoqoldf <- bind_rows(allwhoqol)
```

4) #FILTER ROWS THAT HAVE TOO MANY NA (command to test this is.na) note: if_all function is checking that all of the columns satisfy the condition (not NA)
```{r}
#this is to filter rows that have no NAs in all 26 WHOQOL columns 
#creating a variable w complete_cases to establish new df that only contains rows where all items are filled in (no NA reponse)
complete_cases <- whoqoldf |> 
  filter(if_all(whoqol1:whoqol26, ~ !is.na(.)))

#this is to filter rows that have no NAs in at least one of the 26 WHOQOL columns 
#partial_cases variable created to establish df that has at least one non-missing value among the 26 items
#partial_cases <- x |> 
  #filter(if_any(whoqol1:whoqol26, ~ !is.na(.)))
```

5) EXTRACTING DATE AND LUNDAID FROM THE FILE, counting number of subs and visits per sub
```{r}
#this step creates two new columns from og lunaid (99999_yyddmm)
library(tidyr)
id_date <- whoqoldf |> mutate(lunaid = basename(file)) |> separate(lunaid,c('lunaid', "visitdate")) 

#quick clean (all WHOQOL items are answered) removing NAs and empty strings
#note: . != "" checks that the value is not an empty string
clean <- id_date |> 
  filter(if_all(whoqol1:whoqol26, ~ !is.na(.) & . != ""))

#grouping subject ID and count how many rows per sub ID, n_visit is a new column created
lunaid_grouped <- clean |>
  group_by(lunaid) |> 
  summarise(n_visit = n())

visit_distribution <- lunaid_grouped |>
  count(n_visit, name = "n_subs")
  
```

6) CREATING A NEW FUNCTION THAT USES case_when AND USE IT FOR ALL THE COLUMNS (whoqol1 to whoqol26), THERE IS A TEST CODE AT THE END OF THE CODE BLOCK 
note: define ?as.factor and case_when, why are they important, especially for this? 
```{r}
whoqol_num <- function(x){
  case_when(
    x %in% c("Never", "Not at all", "Very Dissatisfied", "Very dissatisfied", "Very poor", "Very Poor", "1") ~ 1,
    x %in% c("A little", "A Little", "Dissatisfied", "Poor", "Slightly", "Seldom", "2") ~ 2,
    x %in% c("Quite Often", "Quite often", "Neither Dissatisfied nor Satisfied", "Neither dissatisfied nor satisfied", "Neither Poor nor Well", "Neither poor nor well", "Moderately", "A moderate amount", "A Moderate Amount", "Neither Poor nor Good", "Neither poor nor good", "3") ~ 3,
    x %in% c("Very often", "Very Often", "Satisfied", "Well", "Mostly", "Very much", "Very Much",  "Satisfied", "Good", "4") ~ 4,
    x %in% c("Always", "Very Satisfied", "Very satisfied", "Very Good", "Very good", "An extreme amount", "An Extreme Amount", "Extremely", "Completely", "Very well", "Very Well", "5") ~ 5
  )
}

rbind( whoqoldf$whoqol26, whoqol_num(whoqoldf$whoqol26) ) 
whoqol_num(whoqoldf$whoqol26)
```

7) SCORING THIS NOW!!!!!!!!!! LETSGOOOOO
```{r}
#creating a reverse scoring function for 1-5 scale 
revscore <- function (x) {
  return(6- as.numeric(as.character(x)))
}

### we want to reverse score whoqol3 (pain and discomfort), whoqol4(dependence on medicinal substances), and whoqol26(negative feelings) ###

# Convert all whoqol columns from text to numeric (1â€“5)
whoqoldf_scored <- clean |> 
  mutate(across(starts_with("whoqol"), whoqol_num))

whoqoldf_scored <- whoqoldf_scored |>
  mutate(
    whoqol3_rev = revscore(whoqol3),
    whoqol4_rev = revscore(whoqol4),
    whoqol26_rev = revscore(whoqol26)
  )

#score data by domain based on manual yipiiii 
#note: na.rm = TRUE Removes NA, telling R to ignore missing values when computing the mean
#note: rowMeans(across(c(...) is used to compute the average across domain items. 
whoqoldom_scored <- whoqoldf_scored |> 
  mutate(
    D1_physical_raw = rowMeans(across(c(whoqol3_rev, whoqol4_rev, whoqol10, whoqol15, whoqol16, whoqol17, whoqol18)), na.rm = TRUE)*4,
    D2_psych_raw = rowMeans(across(c(whoqol5, whoqol6, whoqol7, whoqol11, whoqol19, whoqol26_rev)), na.rm = TRUE)*4,
    D3_social_raw = rowMeans(across(c(whoqol20, whoqol21, whoqol22)), na.rm = TRUE)*4,
    D4_env_raw = rowMeans(across(c(whoqol8, whoqol9, whoqol12, whoqol13, whoqol14, whoqol23, whoqol24, whoqol25)), na.rm = TRUE)*4
  )
#based on the manual, we need to transform scores to 0-100 scale... create a function then create new df 
#Transformed Score = (RawScore - 4) * (100/16)

transform_whoqol <- function(x) {
  (x - 4) * (100/16)
}

whoqoldom_transformed <- whoqoldom_scored |>
  mutate(
    D1_physical = transform_whoqol(D1_physical_raw), 
    D2_psych = transform_whoqol(D2_psych_raw),
    D3_social = transform_whoqol(D3_social_raw),
    D4_env = transform_whoqol(D4_env_raw)
  )
```

8) MERGING DATASETS & IDENTIFYING TIMEPOINTS & AGE GROUPS
```{r}
#converting lunaids as characters
whoqoldom_transformed$lunaid <- as.character(whoqoldom_transformed$lunaid)
merg7T_raw$lunaid <- as.character(merg7T_raw$lunaid)

whoqol_merge <- left_join(whoqoldom_transformed, merg7T_raw, by = "lunaid", "visitdate")
#converting strings into date format 
whoqol_merge$visitdate <- as.Date(as.character(whoqol_merge$visitdate), format = "%Y%m%d")
whoqol_merge$behave.date <- as.Date(as.character(whoqol_merge$behave.date), format = "%Y%m%d")

#calculating the difference in days
whoqol_merge <- whoqol_merge %>%
  mutate(date_diff = abs(as.numeric(visitdate - behave.date)))
#assigning closest behavioral visit and its visit.no
closest_visit <- whoqol_merge %>%
  group_by(lunaid, visitdate) %>%
  slice_min(order_by = date_diff, n = 1) %>% #selecting rows with the smallest value and take only one single close match (n=1) 
  ungroup()

#removing any duplicated survey responses, only keeping the closest 
clean_visit <- closest_visit %>% 
  group_by(lunaid, visitno) %>%
  filter(!is.na(visitno)) %>%
  slice_min(order_by = date_diff, n = 1) %>% 
  ungroup()

#recounting distribution
clean_distribution <- clean_visit %>%
  filter(!is.na(visitno)) %>%
  count(visitno, name = "n_subs")

#renaming DOB columns
clean_visit <- clean_visit %>% 
  rename(dob1 = Welcome.to.the.LNCD.Survey.Battery....Your.birthday..MM.DD.YYYY..)

clean_visit <- clean_visit %>%
  rename(dob2 = Your.birthday..MM.DD.YYYY..)

#AGE GROUPS: combining DOB columns, convert, calcualte age as of 
clean_visit <- clean_visit %>% 
  mutate(dob_combined = coalesce(dob1, dob2)) %>%
  mutate(dob_combined = as.Date(dob_combined, format = "%m/%d/%Y")) %>%
  mutate(age_behave = as.numeric(difftime(visitdate, dob_combined, units = "weeks")) / 52.25) %>%
  mutate(age_combined = coalesce(behave.age, age_behave))

#reordering my columns so that these variables are at the front and everything else stays in current order
clean_visit <- clean_visit %>%
    select(lunaid, visitdate, behave.date, date_diff, visitno, age_behave, behave.age, age_combined, dob1, dob2, everything())

#creating integers for age_combined
test <- clean_visit %>%
  mutate(age_combined = as.integer(age_combined)) %>%
  filter(!(age_combined %in% c(2000, 2007)))  #some funny ages that were 2000 and 2007, excluding

```

9) HISTOGRAMS AND LINE GRAPHS 
```{r}
library(ggplot2) #loading
library(dplyr) #loading 

#convert to long format -- why? each variable is in its own row (ex: Domain and Score) -- ggplot2 requires long format for grouped plots! (e.g., boxplots, bar charts, line plots, etc.)
#note: pivot_longer helps us do this 
whoqol_long <- clean_visit |>
  select(lunaid, visitno, age_combined, D1_physical:D4_env) |> 
  pivot_longer(cols = D1_physical:D4_env, names_to = "Domain", values_to = "Score") %>%
  ### AGE GROUPS (HISTOGRAM) ###
  mutate(age_group = cut(age_combined,
                         breaks = c(0, 16, 20, 24, 33), 
                         labels = c("10-15", "16-19", "20-23", "24-32")))

### DOMAIN TRENDS ACROSS TIMEPOINTS (LINE) ###
ggplot(whoqol_long, aes(x = visitno, y = Score, color = Domain, group = interaction(Domain, age_group))) + 
  stat_summary(fun = mean, geom = "line", linewidth = 1) +
  stat_summary(fun = mean, geom = "point", size = 2) + 
  facet_wrap(~ age_group) +
  labs(title = "WHOQOL DOMAIN SCORES OVER TIME",
       x = "Time",
       y = "Score") + 
  theme_classic()

ggplot(whoqol_long, aes(x = Score, fill = age_group)) +
  geom_histogram(position = "identity", alpha = 0.6, bins = 30) +
  facet_wrap(~ Domain, scales = "free") +
  labs(title = "WHOQOL Domain Scores by Age Group",
       x = "Domain Score",
       y = "Count") +
  theme_minimal()


### BASELINE (BOXPLOT) ###
#note: for each lunaid group this selects rows with min visitdate
#note: with_ties = FALSE means if multiple rows share the exame same earliest visitdate, to only pick one row so there are no duplicates. 
whoqol_baseline <- clean_visit %>% 
  group_by(lunaid) %>%
  slice_min(visitno, with_ties = FALSE) %>% 
  rename_with(~paste0(.,"_baseline"), -lunaid)  # rename columns except lunaid

whoqol_baseline_long <- whoqol_baseline %>% pivot_longer( cols = D1_physical_baseline:D4_env_baseline, names_to = "Domain", values_to = "Score")

print(
  ggplot(whoqol_baseline_long, aes(x = Domain, y = Score, fill = Domain)) + 
  geom_boxplot() +
  labs(title = "Baseline WHOQOL Scores by Domain") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
```

10) RUNNING SOME TESTS 
- Linear Regression Model
```{r}
#LINEAR REGRESSION MODEL - How does age predict different WHOQOL-BREF domains? 
#note: model <- lm(outcome ~ x + y, data = your_dataframe)

model_physical <- lm(D1_physical ~ age_combined, data = test)
summary(model_physical)

model_psych <- lm(D2_psych ~ age_combined, data = test) 
summary(model_psych)

model_social <- lm(D3_social ~ age_combined, data = test) 
summary(model_social)

model_env <- lm(D4_env ~ age_combined, data = test)
summary(model_env)

model_all <- lm(cbind(D1_physical, D2_psych, D3_social, D4_env) ~ age_combined, data = test)
summary(model_all)

#visualize Linear Regression Models 
library(ggplot2)

ggplot(test, aes(x = age_combined, y = D1_physical)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Age effect on Physical Domain", x = "Age", y = "Physical Domain Score")

ggplot(test, aes(x = age_combined, y = D2_psych)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Age effect on Psych Domain", x = "Age", y = "Psych Domain Score")

ggplot(test, aes(x = age_combined, y = D3_social)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Age effect on Social Domain", x = "Age", y = "Social Domain Score")

ggplot(test, aes(x = age_combined, y = D4_env)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Age effect on Environment Domain", x = "Age", y = "Environment Domain Score")
```

