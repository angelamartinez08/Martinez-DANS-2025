---
title: "WHOQOLBREF LEARNING"
output: html_document
date: "2025-08-13"
---
1) FIRST THINGS FIRST :P
```{r}
setwd("/Volumes/Hera/Angela")
load('/Volumes/Hera/Projects/7TBrainMech/scripts/behave/svys.RData')
library(dplyr)
```
RANDOM LOL REVISIT no need to look now
```{r}
Y2HF <- svys[["7T Y2 Hybrid Female Survey Battery"]] #EXTRACTING IT INTO DATAFRAME

all_csv <- Sys.glob('/Volumes/L/bea_res/Data/Temporary Raw Data/7T/*/*_selfreport.csv') #finding where all those files are, the * is a placeholder(glob placeholder)

```

IN DIFFERENT BATTERIES THE WHOQOL QUESTIONS WILL BE IN A DIFFERENT POSITION SVY BATTERIES

2) LOOK FOR WHOQOL ITEMS!!!
note: this is how we can look for specific items that we want to work within the data! 
```{r}
names(data) |> grep(pattern = 'quality')
# answer is 467
names(data) |> grep(pattern = 'quality', value = TRUE)
# answer is "Q173...How.would.you.rate.your.quality.of.life."
```

3) CREATING A FUNCTION TO READ WHOQOL STUFF <3
note: curly brackets defines the functions code; this function reads in CSV files, will extract specific columns related to WHOQOL items plus some demo info, and renames the columns, and returns only the last row of data to use later (f iS placeholder for filename) 
```{r}
readwhoqol <- function(f) {
   d <- read.csv(f, skip = 1)
   if(ncol(d) < 20) return(NULL) #a quick qc to ignore files with missing/incomplete data
  dob <- names(d) |> grep(pattern = "birthday")
  #d[dob] <- as.character(d[dob]) 
  sex <- names(d) |> grep(pattern = "gender")
  #d[sex] <- as.character(d[sex])
  i <- names(d) |> grep(pattern = 'quality')
  names(d)[i: (i+25)] <- paste('whoqol', 1:26, sep = '') #renaming columns to be whoqol1 to whoqol26
  eyes <- c(i: (i+25), sex, dob) #columns of interest to extract from
  whoqol <- d [, eyes] |> mutate(across(everything(), as.character))
  whoqol$file <- f
  return(whoqol[nrow(whoqol),])
}

allwhoqol <- lapply(all_csv, readwhoqol)
whoqoldf <- bind_rows(allwhoqol)
```

4) #HOMEWORK FILTER ROWS THAT HAVE TOO MANY NA (command to test this is.na) note: if_all function is checking that all of the columns satify the condition (not NA)

WF Notes(20250827): 
 * be sure to assign these outputs to another variable: `whoqoldf_nona <- whoqoldf |> filter(...)`
 * `x` doesn't exist yet (created in the hunk below). want to pull that up first.
 * `if_any !is.na` is probbly too generous and if_all too rigerous. maybe if_all on just a subset of columns? `whoqol1:whoqol26`

```{r}
#this is to filter rows that have no NAs in all 26 WHOQOL columns 
x |> 
  filter(if_all(whoqol1:whoqol26, ~ !is.na(.))) |> 
  nrow()

#this is to filter rows that have no NAs in at least one of the 26 WHOQOL columns 
x |> 
  filter(if_any(whoqol1:whoqol26, ~ !is.na(.))) |> 
  nrow()
```

***5) EXTRACTING DATE AND LUNDAID FROM THE FILE, WHAT WILL BE THE FINAL N??? -- HOMEWORK: GROUP SUB DATA BY LUNAID
```{r}
library(tidyr)
x <- whoqoldf |> mutate(lunaid = basename(file)) |> separate(lunaid,c('lunaid', "visitdate"))
```

6) CREATING A NEW FUNCTION THAT USES case_when AND USE IT FOR ALL THE COLUMNS (whoqol1 to whoqol26), THERE IS A TEST CODE AT THE END OF THE CODE BLOCK 
note: define ?as.factor and case_when, why are they important, especially for this? 
```{r}
whoqol_num <- function(x){
  case_when(
    x %in% c("Never", "Not at all", "Very dissatisfied", "Very poor", "1") ~ 1,
    x %in% c("A little", "Dissatisfied", "Poor", "Slightly", "Seldom", "2") ~ 2,
    x %in% c("Quite often", "Neither satisfied or dissatisfied", "Neither poor nor well", "Moderately", "A moderate amount", "Neither poor nor good", "3") ~ 3,
    x %in% c("Very often", "Satisfied", "Well", "Mostly", "Very much", "Satisfied", "Good", "4") ~ 4,
    x %in% c("Always", "Very satisfied", "Very good", "An extreme amount", "Extremely", "Completely", "Very well", "5") ~ 5
  )
}

rbind( whoqoldf$whoqol26, whoqol_num(whoqoldf$whoqol26) ) 
whoqol_num(whoqoldf$whoqol26)
```

7) SCORING THIS NOW!!!!!!!!!! LETSGOOOOO
```{r}
#creating a reverse scoring function for 1-5 scale 
revscore <- function (x) {
  return(6- as.numeric(as.character(x)))
}

### we want to reverse score whoqol3 (pain and discomfort), whoqol4(dependence on medicinal substances), and whoqol26(negative feelings) ###

# Convert all whoqol columns from text to numeric (1â€“5)
whoqoldf_num <- whoqoldf |> 
  mutate(across(starts_with("whoqol"), whoqol_num))
```


WF Notes(20250827): 
  * maybe save all revscored as new columns instead of overwriting the originals.  as e.g `whoqol3_rev` so we know where all the data comes and goes
  * `rowMeans` with na.rm is great! I didn't know that could be used with across!

```{r}

whoqoldf_num <- whoqoldf_num |>
  mutate(
    whoqol3 = revscore(whoqol3),
    whoqol4 = revscore(whoqol4),
    whoqol26 = revscore(whoqol26)
  )

## score data by domain yipiiii ## note: na.rm = TRUE Removes NA, then computes -- note: rowMeans(across(c(...) is used to compute the mean of several columns across each row
whoqoldf_scored <- whoqoldf_num |> 
  mutate(
    D1_physical = rowMeans(across(c(whoqol3, whoqol4, whoqol10, whoqol15, whoqol16, whoqol17, whoqol18)), na.rm = TRUE),
    D2_psych = rowMeans(across(c(whoqol5, whoqol6, whoqol7, whoqol11, whoqol19, whoqol26)), na.rm = TRUE),
    D3_social = rowMeans(across(c(whoqol20, whoqol21, whoqol22)), na.rm = TRUE),
    D4_env = rowMeans(across(c(whoqol8, whoqol9, whoqol12, whoqol13, whoqol14, whoqol23, whoqol24, whoqol25)), na.rm = TRUE)
  )


```



