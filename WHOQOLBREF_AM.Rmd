---
title: "WHOQOLBREF LEARNING"
output: html_document
date: "2025-08-13"
---
1) FIRST THINGS FIRST :P
```{r}
setwd("/Volumes/Hera/Angela")
load('/Volumes/Hera/Projects/7TBrainMech/scripts/behave/svys.RData')
library(dplyr)
```
RANDOM LOL REVISIT no need to look now
```{r}
Y2HF <- svys[["7T Y2 Hybrid Female Survey Battery"]] #EXTRACTING IT INTO DATAFRAME

all_csv <- Sys.glob('/Volumes/L/bea_res/Data/Temporary Raw Data/7T/*/*_selfreport.csv') #finding where all those files are, the * is a placeholder(glob placeholder)

```

IN DIFFERENT BATTERIES THE WHOQOL QUESTIONS WILL BE IN A DIFFERENT POSITION SVY BATTERIES

2) LOOK FOR WHOQOL ITEMS!!!
note: this is how we can look for specific items that we want to work within the data! 
```{r}
names(data) |> grep(pattern = 'quality')
# answer is 467
names(data) |> grep(pattern = 'quality', value = TRUE)
# answer is "Q173...How.would.you.rate.your.quality.of.life."
```

3) CREATING A FUNCTION TO READ WHOQOL STUFF <3
note: curly brackets defines the functions code; this function reads in CSV files, will extract specific columns related to WHOQOL items plus some demo info, and renames the columns, and returns only the last row of data to use later (f iS placeholder for filename) 
```{r}
readwhoqol <- function(f) {
   d <- read.csv(f, skip = 1)
   if(ncol(d) < 20) return(NULL) #a quick qc to ignore files with missing/incomplete data
  dob <- names(d) |> grep(pattern = "birthday")
  #d[dob] <- as.character(d[dob]) 
  sex <- names(d) |> grep(pattern = "gender")
  #d[sex] <- as.character(d[sex])
  i <- names(d) |> grep(pattern = 'quality')
  names(d)[i: (i+25)] <- paste('whoqol', 1:26, sep = '') #renaming columns to be whoqol1 to whoqol26
  eyes <- c(i: (i+25), sex, dob) #columns of interest to extract from
  whoqol <- d [, eyes] |> mutate(across(everything(), as.character))
  whoqol$file <- f
  return(whoqol[nrow(whoqol),])
}

allwhoqol <- lapply(all_csv, readwhoqol)
whoqoldf <- bind_rows(allwhoqol)
```

4) #FILTER ROWS THAT HAVE TOO MANY NA (command to test this is.na) note: if_all function is checking that all of the columns satisfy the condition (not NA)
```{r}
#this is to filter rows that have no NAs in all 26 WHOQOL columns 
#creating a variable w complete_cases to establish new df that only contains rows where all items are filled in (no NA reponse)
complete_cases <- whoqoldf |> 
  filter(if_all(whoqol1:whoqol26, ~ !is.na(.)))

#this is to filter rows that have no NAs in at least one of the 26 WHOQOL columns 
#partial_cases variable created to establish df that has at least one non-missing value among the 26 items
#partial_cases <- x |> 
  #filter(if_any(whoqol1:whoqol26, ~ !is.na(.)))
```

***5) EXTRACTING DATE AND LUNDAID FROM THE FILE, counting number of subs and visits per sub
```{r}
#this step creates two new columns from og lunaid (99999_yyddmm)
library(tidyr)
id_date <- whoqoldf |> mutate(lunaid = basename(file)) |> separate(lunaid,c('lunaid', "visitdate")) 

#quick clean (all WHOQOL items are answered) removing NAs and empty strings
#note: . != "" checks that the value is not an empty string
clean <- id_date |> 
  filter(if_all(whoqol1:whoqol26, ~ !is.na(.) & . != ""))

#grouping subject ID and count how many rows per sub ID, n_visit is a new column created
lunaid_grouped <- clean |>
  group_by(lunaid) |> 
  summarise(n_visit = n())

visit_distribution <- lunaid_grouped |>
  count(n_visit, name = "n_subs")
  
```

6) CREATING A NEW FUNCTION THAT USES case_when AND USE IT FOR ALL THE COLUMNS (whoqol1 to whoqol26), THERE IS A TEST CODE AT THE END OF THE CODE BLOCK 
note: define ?as.factor and case_when, why are they important, especially for this? 
```{r}
whoqol_num <- function(x){
  case_when(
    x %in% c("Never", "Not at all", "Very Dissatisfied", "Very dissatisfied", "Very poor", "Very Poor", "1") ~ 1,
    x %in% c("A little", "A Little", "Dissatisfied", "Poor", "Slightly", "Seldom", "2") ~ 2,
    x %in% c("Quite Often", "Quite often", "Neither Dissatisfied nor Satisfied", "Neither dissatisfied nor satisfied", "Neither Poor nor Well", "Neither poor nor well", "Moderately", "A moderate amount", "A Moderate Amount", "Neither Poor nor Good", "Neither poor nor good", "3") ~ 3,
    x %in% c("Very often", "Very Often", "Satisfied", "Well", "Mostly", "Very much", "Very Much",  "Satisfied", "Good", "4") ~ 4,
    x %in% c("Always", "Very Satisfied", "Very satisfied", "Very Good", "Very good", "An extreme amount", "An Extreme Amount", "Extremely", "Completely", "Very well", "Very Well", "5") ~ 5
  )
}

rbind( whoqoldf$whoqol26, whoqol_num(whoqoldf$whoqol26) ) 
whoqol_num(whoqoldf$whoqol26)
```

7) SCORING THIS NOW!!!!!!!!!! LETSGOOOOO
```{r}
#creating a reverse scoring function for 1-5 scale 
revscore <- function (x) {
  return(6- as.numeric(as.character(x)))
}

### we want to reverse score whoqol3 (pain and discomfort), whoqol4(dependence on medicinal substances), and whoqol26(negative feelings) ###

# Convert all whoqol columns from text to numeric (1–5)
whoqoldf_scored <- clean |> 
  mutate(across(starts_with("whoqol"), whoqol_num))

whoqoldf_scored <- whoqoldf_scored |>
  mutate(
    whoqol3_rev = revscore(whoqol3),
    whoqol4_rev = revscore(whoqol4),
    whoqol26_rev = revscore(whoqol26)
  )

#score data by domain based on manual yipiiii 
#note: na.rm = TRUE Removes NA, telling R to ignore missing values when computing the mean
#note: rowMeans(across(c(...) is used to compute the average across domain items. 
whoqoldom_scored <- whoqoldf_scored |> 
  mutate(
    D1_physical_raw = rowMeans(across(c(whoqol3_rev, whoqol4_rev, whoqol10, whoqol15, whoqol16, whoqol17, whoqol18)), na.rm = TRUE),
    D2_psych_raw = rowMeans(across(c(whoqol5, whoqol6, whoqol7, whoqol11, whoqol19, whoqol26_rev)), na.rm = TRUE),
    D3_social_raw = rowMeans(across(c(whoqol20, whoqol21, whoqol22)), na.rm = TRUE),
    D4_env_raw = rowMeans(across(c(whoqol8, whoqol9, whoqol12, whoqol13, whoqol14, whoqol23, whoqol24, whoqol25)), na.rm = TRUE)
  )
#based on the manual, we need to transform scores to 0-100 scale... create a function then create new df 
#Transformed Score = (RawScore - 4) * (100/16)

transform_whoqol <- function(x) {
  (x - 4) * (100/16)
}

whoqoldom_transformed <- whoqoldom_scored |>
  mutate(
    D1_physical = transform_whoqol(D1_physical_raw), 
    D2_psych = transform_whoqol(D2_psych_raw),
    D3_social = transform_whoqol(D3_social_raw),
    D4_env = transform_whoqol(D4_env_raw)
  )
```

8) MAKING CUTE VISUALS
```{r}
library(ggplot2) #loading

#convert to long format -- why? each variable is in its own row (ex: Domain and Score) -- ggplot2 requires long format for grouped plots! (e.g., boxplots, bar charts, line plots, etc.)
#note: pivot_longer helps us do this 
whoqol_long <- whoqoldom_transformed |>
  select(lunaid, visitdate, D1_physical:D4_env) |> 
  pivot_longer(cols = D1_physical:D4_env, names_to = "Domain", values_to = "Score")

#line plot over time / domain trends
ggplot(whoqol_long, aes(x = visitdate, y = Score, color = Domain, group = Domain)) + 
  stat_summary(fun = mean, geom = "line", size = 1) +
  stat_summary(fun = mean, geom = "point", size = 2) + 
  labs(title = "WHOQOL DOMAIN SCORES OVER TIME",
       x = "Time",
       y = "Score") + 
  theme_classic()

#what about baseline vs most recent? 
library(dplyr) #loading 

#Baseline
whoqol_baseline <- whoqoldom_transformed %>% 
  group_by(lunaid) %>%
  slice_min(visitdate, with_ties = FALSE) %>%
  ungroup() %>%
  rename_with(~paste0(.,"_baseline"), -lunaid)  # rename columns except lunaid

#Recent
whoqol_recent <- whoqoldom_transformed %>% 
  group_by(lunaid) %>% 
  slice_max(visitdate, with_ties = FALSE) %>% 
  ungroup() %>% 
  rename_with(~paste0(., "_recent"), -lunaid) 

#joining baseline and most recent
whoqol_compare <- whoqol_baseline %>%
  inner_join(whoqol_recent, by = "lunaid")

#calculating the difference between the two
whoqol_diff <- whoqol_compare %>%
  mutate(
    change_physical = D1_physical_recent - D1_physical_baseline,
    change_psych = D2_psych_recent - D2_psych_baseline, 
    change_social = D3_social_recent - D3_social_baseline,
    change_env = D4_env_recent - D4_env_baseline
  )

#running paired t-tests to see statistical comparisons
t.test(whoqol_compare$D1_physical_recent, whoqol_compare$D1_physical_baseline, paired = TRUE)
t.test(whoqol_compare$D2_psych_recent, whoqol_compare$D2_psych_baseline, paired = TRUE)
t.test(whoqol_compare$D3_social_recent, whoqol_compare$D3_social_baseline, paired = TRUE)
t.test(whoqol_compare$D4_env_recent, whoqol_compare$D4_env_baseline, paired = TRUE)

#based on given data no stat. significance but still needs to be cleaned up, revisit. 

#plotting the data
plot_data <- whoqol_compare %>%
  select(lunaid,
         D1_physical_baseline, D1_physical_recent) %>%
  pivot_longer(cols = -lunaid,
               names_to = c("Domain", "Time"),
               names_sep = "_",
               values_to = "Score")

ggplot(whoqol_long, aes(x = visitdate, y = Score, group = lunaid, color = Domain)) +
  geom_line(alpha = 0.3) +
  facet_wrap(~ Domain) +
  labs(title = "Individual WHOQOL Scores Over Time",
       x = "Time", y = "Score (0–100)") +
  theme_minimal()



```

